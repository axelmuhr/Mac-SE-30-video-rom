;; ---- This is THE DRIVER -----;;VidDrvr:        dc.w $4C00              ; ctl, status, needsLock                dc.w 0                dc.w 0                dc.w 0				; entry point offset table                dc.w VideoOpen-VidDrvr 	; open routine                dc.w VidDrvr-VidDrvr 	; no prime	                dc.w VideoCtl-VidDrvr	; control	                dc.w VideoStatus-VidDrvr; status	                dc.w VideoClose-VidDrvr	; close						                dc.b $23                ; PASCAL string sizeVideoTitle		dc.b '.Display_Video_Apple_MacSE/30 Video'				STRING		ASIS                ALIGN 2                dc.w 0					; Driver Version; ---------------------------------------------------------------------------VideoOpen:                              ; Global: hardware configuration flags - check for A/UX                btst    #9,($B22).w                bne.s   runningAUX      ; branch if we run AU/X                movea.l ($134).w,a0     ; Global var SonyVars - ptr to Mac 3.5" Disk Driver variables                lea     mysteriousData(pc),a3                move.l  a3,$130(a0)     ; Offset $130 to SonyVars is what? (over)writes at $5E18                                        ; This will by replaced by the 'mysterious data', most                                        ; likely some alternative/patched ROM calls (???)runningAUX:                                             moveq   #$C,d0                ;_ReserveMemSys - manually encoded as MPW3.2 don't like them				dc.w	$A440				                moveq   #$C,d0                ;_NewHandleSysClear				dc.w	$A722				                bne.s   voExitErr                move.l  a0,$14(a1)                _HLock                movea.l (a0),a3                bsr.w   installIntHandler                bne.s   voExitIntErr                move.l  a0,6(a3)                moveq   #0,d0                bsr.w   switchPage                moveq   #0,d0voExit:                                                rts; ---------------------------------------------------------------------------voExitIntErr:                                           movea.l $14(a1),a0                _DisposeHandlevoExitErr:                                              moveq   #$FFFFFFE9,d0                bra.s   voExit; ---------------------------------------------------------------------------; Video Driver Control Call Handler;    (0) Reset;    (1) KillIO;    (2) SetMode;    (3) SetEntries;    (4) SetGamma;    (5) GrayPage;    (6) SetGray;    (7) SetInterrupt;    (8) DirectSetEntries;    (9) SetDefaultMode; Entry: A0 = IO parameter block pointer;        Al = DCE pointer;; Uses:  A2 = cs parameters (ie. A2 <- csParam(AO));        A3 = pointer to private storage;        A4 = scratch (must be preserved);        D0-D3 = scratch (don't need to be preserved);; Exit:  D0 = error code;VideoCtl:       movem.l d4/a0-a1/a3-a4,-(sp)                move.w  $1A(a0),d0      ; get the opCode                movea.l $1C(a0),a2      ; A2 <- ptr to control parameters                movea.l ([$14,a1]),a3   ; dCtlStorage - driver's private storage [handle]                cmpi.w  #7,d0           ; switch 8 cases                bhi.s   ctrlExitBad     ; jumptable 0000023C default case, cases 3,4,6                move.w  ctrlJumpTbl(pc,d0.w*2),d0                jmp     ctrlJumpTbl(pc,d0.w) ; switch jump; ---------------------------------------------------------------------------ctrlJumpTbl:    dc.w VidReset-ctrlJumpTbl                      dc.w ctrlExitGood-ctrlJumpTbl  ; no SetEntries (we're MONO,dude!)                dc.w ctrlSetVidMode-ctrlJumpTbl                dc.w ctrlExitBad-ctrlJumpTbl                dc.w ctrlExitBad-ctrlJumpTbl                dc.w setGrayPage-ctrlJumpTbl                dc.w ctrlExitBad-ctrlJumpTbl                dc.w ctrlSetInt-ctrlJumpTbl; ---------------------------------------------------------------------------ctrlExitBad:                                                                                    moveq   #$FFFFFFEF,d0   ; jumptable default case, cases 3,4,6                bra.s   ctrlExit; ---------------------------------------------------------------------------ctrlExitGood:                                                                                   moveq   #0,d0           ctrlExit:                                               movem.l (sp)+,d4/a0-a1/a3-a4                bra.w   chkQueue; ---------------------------------------------------------------------------VidReset:                                                                                       move.w  #$80,(a2)                       moveq   #0,d0                move.w  d0,6(a2)                bsr.w   switchPage                move.l  2(a3),8(a2)                bsr.w   drawBackground                bra.s   ctrlExitGood    ; ---------------------------------------------------------------------------ctrlSetVidMode:                                                                                 cmpi.w  #$80,(a2)                       bne.s   ctrlExitBad                     move.w  6(a2),d0                bmi.s   ctrlExitBad                     cmpi.w  #1,d0                bgt.s   ctrlExitBad                     bsr.w   switchPage                move.l  2(a3),8(a2)                bra.s   ctrlExitGood    ; ---------------------------------------------------------------------------setGrayPage:                                                                                    bsr.w   drawBackground                  bra.s   ctrlExitGood    ; ---------------------------------------------------------------------------ctrlSetInt:                                                                                     move.b  (a2),d0                         bfins   d0,$A(a0){0:1}                bne.s   removeInt                bsr.s   installIntHandler                bne.s   ctrlExitBad                     move.l  a0,6(a3)                bra.s   ctrlExitGood    ; ---------------------------------------------------------------------------removeInt:                                              bsr.s   removeIntHandler                bra.s   ctrlExitGood    ; =============== S U B R O U T I N E =======================================removeIntHandler:                                       move.b  $28(a1),d0                movea.l ($1D4).w,a2 	; [GLOBAL VAR] VIA base address                bset    #6,(a2)                movea.l 6(a3),a0                _SIntRemove                _DisposePtr                rts; End of function removeIntHandler; =============== S U B R O U T I N E =======================================installIntHandler:                                                                              lea     intHandler(pc),a2 ; load address of the interupt handling routine                moveq   #$10,d0                _NewPtrSysClear                bne.s   instIntErr      ; we couldn't even get a pointer... so leave                move.w  #6,4(a0)                move.l  a2,8(a0)                movea.l $2A(a1),a2                move.l  a2,$C(a0)                move.b  $28(a1),d0                _SIntInstall                bne.s   instIntDisPointer ; on error dispose pointer                movea.l ($1D4).w,a2     ; [GLOBAL VAR] VIA base address                bclr    #6,(a2)         ; 0 = vertical synchronization interrupt enabled                cmp.b   d0,d0           ; zero D0                rts; ---------------------------------------------------------------------------instIntDisPointer:                                      _DisposePtrinstIntErr:                                             moveq   #1,d0                rts; End of function installIntHandler; ---------------------------------------------------------------------------VideoClose:                movea.l ([$14,a1]),a3                bsr.s   removeIntHandler                movea.l $14(a1),a0                _DisposeHandle                moveq   #0,d0                rts; ---------------------------------------------------------------------------; -----------------------------------------------------; Video driver status call handler; (0) Error; (1) Error; (2) GetMode; (3) GetEntries; (4) GetPage; (5) GetPageBase; (6) GetGray; (7) GetInterrupt; (8) GetGamma; (9) GetDefaultMode;; Entry: A0 = param block;        A1 = DCE pointer; Exit:  D0 = error code; -----------------------------------------------------;VideoStatus:    move.l  a0,-(sp)                move.w  $1A(a0),d0                movea.l $1C(a0),a2                movea.l ([$14,a1]),a3   ; dCtlStorage - driver's private storage [handle]                cmpi.w  #8,d0           ; switch 9 cases                bhi.s   statExitBad                     move.w  statJumpTbl(pc,d0.w*2),d0                jmp     statJumpTbl(pc,d0.w) ; switch jump; ---------------------------------------------------------------------------statJumpTbl:    dc.w statExitBad-statJumpTbl                   dc.w statExitBad-statJumpTbl                   dc.w getMode-statJumpTbl                dc.w getEntries-statJumpTbl                dc.w getPage-statJumpTbl                dc.w getPageBase-statJumpTbl                dc.w statExitBad-statJumpTbl                dc.w statGetInt-statJumpTbl                dc.w statExitBad-statJumpTbl; ---------------------------------------------------------------------------statExitBad:                                                                                  moveq   #$FFFFFFEE,d0   ; jumptable default case, cases 0,1,6,8                bra.s   statExit; ---------------------------------------------------------------------------statExitGood:                                                                       moveq   #0,d0statExit:                                               movea.l (sp)+,a0                bra.s   chkQueue; ---------------------------------------------------------------------------getMode:                                                                                       move.w  #$80,(a2)                       move.w  (a3),6(a2)                move.l  2(a3),8(a2)                bra.s   statExitGood; ---------------------------------------------------------------------------getEntries:                                                                                   tst.l   (a2)                            beq.s   statExitBad                     subq.w  #4,sp                _GetCTSeed                movea.l (a2),a0                move.l  (sp)+,(a0)+                move.l  #$80000001,(a0)+                move.l  #$FFFF,(a0)+                move.l  ($A06).w,(a0)+  ; [GLOBAL VAR] $FFFFFFFF, constant "Minus One"                clr.l   (a0)+                clr.l   (a0)+                bra.s   statExitGood; ---------------------------------------------------------------------------getPage:                                                                                   move.w  #2,6(a2)                        bra.s   statExitGood; ---------------------------------------------------------------------------getPageBase:                                                                                   move.w  6(a2),d0                        bmi.s   statExitBad                     cmpi.w  #1,d0                bgt.s   statExitBad                     bne.s   loc_39E		                move.l  #$FEE08040,8(a2) ; screenbase                bra.s   loc_3A6; ---------------------------------------------------------------------------loc_39E:     		                move.l  #$FEE00040,8(a2)loc_3A6:                                                bra.s   statExitGood; ---------------------------------------------------------------------------statGetInt:                                                                                 bfextu  $A(a3){0:1},d0  ; Get the highest bit of $A(a3) into D0 - Bitfield is Little Endian!                move.w  d0,(a2)                bra.s   statExitGood; ---------------------------------------------------------------------------chkQueue:                                                                                btst    #9,6(a0)        ; noQueue' bit set? (6(a0) ponting to ioTrap table)                beq.s   exitDriver      ; if yes, we're done here                rts; ---------------------------------------------------------------------------exitDriver:                                             movea.l ($8FC).w,a0      ; [GLOBAL VAR] Jump vector for IODone function                jmp     (a0); =============== S U B R O U T I N E =======================================switchPage:                                                                                    movem.l d0/a0,-(sp)                movea.l ($1D4).w,a0     ; VIA base                bset    #6,$600(a0)     ; set 6th bit of vDIRA to output                adda.w  #$1E00,a0       ; pointer to VIA1 Data Register A by adding the offset 0x1E00                move.w  d0,(a3)                beq.s   swMainPage                bclr    #6,(a0)         ; clear 6th bit of Data Register - ie. alternate video page                move.l  #$FEE00040,d0   ; alternative screenbase                bra.s   switchExit; ---------------------------------------------------------------------------swMainPage:                                             bset    #6,(a0)         ; set 6th bit of Data Reg.A, main video page                move.l  #$FEE08040,d0   ; main screenbaseswitchExit:                                            move.l  d0,2(a3)                movem.l (sp)+,d0/a0                rts; End of function switchPage; This clears the screen to the 'grey' background, i.e.; 010101010101010101010...; 101010101010101010101...; =============== S U B R O U T I N E =======================================drawBackground:                                        movem.l d0-d2/a0,-(sp)                move.l  #$AAAAAAAA,d0   ; inital pattern                movea.l 2(a3),a0        ; get screenbase (from variable this time)                move.w  #$155,d2bgLine:                                                 move.w  #$F,d1bgColumn:                                               move.l  d0,(a0)+                dbf     d1,bgColumn                not.l   d0				; invert pattern                dbf     d2,bgLine                movem.l (sp)+,d0-d2/a0                rts; End of function drawBackground; ---------------------------------------------------------------------------intHandler:                                             movea.l ($1D4).w,a0     ; VIA base                bset    #6,$400(a0)     ; Direction B                bset    #6,(a0)                bclr    #6,(a0)                move.l  a1,d0                rol.l   #8,d0                andi.w  #$F,d0                movea.l ($D28).w,a0     ;  [GLOBAL VAR]  vector to slot VBL task interrupt handle                jsr     (a0)                moveq   #1,d0                rts; ---------------------------------------------------------------------------mysteriousData: dc.l $D010E                          dc.l $3000D                dc.l $C0103                dc.l 0                dc.l 0                dc.l 0                dc.l 0                dc.l 0                dc.l 0                dc.l $7FFF8000                dc.l $80004000                dc.l $9FFE4000                dc.l $A0014000                dc.l $A0014000                dc.l $A0014000                dc.l $A0014000                dc.l $A0014000                dc.l $A0014040                dc.l $A0014040                dc.l $A0014040                dc.l $9FFE4040                dc.l $800041F0                dc.l $800040E0                dc.l $80004040                dc.l $80FE4000                dc.l $80005FFF                dc.l $80005001                dc.l $80005001                dc.l $800053F9                dc.l $7FFF9001                dc.l $40009001                dc.l $7FFF9FFF                dc.l 0                dc.l 0                dc.l 0                dc.l 0                dc.l 0                dc.l 0                dc.l 0                dc.l 0                dc.l 0                dc.l $7FFF8000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFC000                dc.l $FFFFDFFF                dc.l $FFFFDFFF                dc.l $FFFFDFFF                dc.l $FFFFDFFF                dc.l $7FFF9FFF                dc.l $7FFF9FFF                dc.l $7FFF9FFF                dc.l 0                dc.l 0                dc.l 0                dc.l 0                dc.l $7FF                dc.l $FFE00800                dc.l $100800                dc.l $1008FF                dc.l $FF100900                dc.l $900955                dc.l $50900900                dc.l $900955                dc.l $900900                dc.l $900950                dc.l $900900                dc.l $900950                dc.l $900900                dc.l $900954                dc.l $900900                dc.l $900900                dc.l $9008FF                dc.l $FF100800                dc.l $100800                dc.l $100800                dc.l $100810                dc.l $100818                dc.l $1008FC                dc.l $FF100818                dc.l $100810                dc.l $100800                dc.l $1007FF                dc.l $FFE00400                dc.l $200400                dc.l $200400                dc.l $2003FF                dc.l $FFC00000                dc.l $7FF                dc.l $FFE00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF00FFF                dc.l $FFF007FF                dc.l $FFE007FF                dc.l $FFE007FF                dc.l $FFE007FF                dc.l $FFE003FF                dc.l $FFC00000